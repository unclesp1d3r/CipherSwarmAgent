---
inclusion: always
---

# CipherSwarmAgent: Core Rules

## 1. Core Design Rules

- All API interactions must match the v1 Agent API contract in `docs/swagger.json` exactly. Breaking changes are prohibited.
- The agent is a long-lived CLI client responsible for:
  - Authenticating and registering itself
  - Checking in (heartbeat)
  - Receiving and executing cracking tasks
  - Submitting benchmark, crack results, and status updates
- Each agent handles one task at a time. No task queueing or parallel execution is allowed.

## 2. API Contract

- API base path: `/api/v1/client/`
- Authentication via `Authorization: Bearer <token>`
- Endpoints to support:
  - `GET /authenticate` — authenticate and register the agent
  - `GET /configuration` — fetch config settings
  - `GET /agents/{id}` — get agent details
  - `PUT /agents/{id}` — update agent metadata
  - `POST /agents/{id}/heartbeat` — heartbeat
  - `POST /agents/{id}/shutdown` — notify of shutdown
  - `POST /agents/{id}/submit_benchmark` — send benchmark results
  - `POST /agents/{id}/submit_error` — send structured error
  - `GET /attacks/{id}` — fetch attack config
  - `GET /attacks/{id}/hash_list` — download hash list
  - `GET /tasks/new` — poll for new task
  - `GET /tasks/{id}` — get task details
  - `POST /tasks/{id}/accept_task` — accept a task
  - `POST /tasks/{id}/abandon` — abandon a task (e.g., on shutdown)
  - `POST /tasks/{id}/submit_crack` — submit cracked result
  - `POST /tasks/{id}/submit_status` — submit status update
  - `POST /tasks/{id}/exhausted` — report task exhaustion
  - `GET /tasks/{id}/get_zaps` — retrieve shared crack files
- Response parsing must conform to the schemas defined in `docs/swagger.json`.
- The API client is generated by oapi-codegen from `docs/swagger.json` — never hand-roll HTTP endpoints.

## 3. Hashcat Execution

- The agent must support launching hashcat via CLI, capturing stdout/stderr, and parsing real-time output.
- Status updates must parse lines from `--status` JSON or standard output and transform them into the `TaskStatus` schema.
- Cracked results must be deduplicated before submission.
- Benchmarking must support both `--benchmark` and `--benchmark-all` as determined by configuration.

## 4. Configuration and Persistence

- Use local file-based configuration (YAML) for:
  - Agent token
  - Server URL
  - Data paths, GPU thresholds, fault tolerance settings
- Allow override via CLI flags and environment variables.
- Configuration fetched from `/configuration` may override local defaults, but local overrides should take precedence unless explicitly allowed.
- Configuration defaults live in `lib/config/config.go` as exported constants.
- Config access: read from `agentstate.State`, not `viper.Get*()` directly.

## 5. Reliability and Error Handling

- Implement exponential backoff for all failed API requests.
- Network or API errors should be logged and retried when safe.
- Fatal errors should be reported to `/submit_error` with full metadata via `cserrors.SendAgentError`.
- A shutdown routine should gracefully notify the server and abandon any active task.

## 6. Compatibility and Modularity

- Code must be modular and testable. Key sub-packages:
  - `lib/api/` — API client (generated + hand-written wrapper)
  - `lib/task/` — Task lifecycle management
  - `lib/hashcat/` — Hashcat session runner
  - `lib/benchmark/` — Benchmark execution and caching
- Minimize coupling between internal logic and transport. The agent should be testable without live API calls.

## 7. Task Lifecycle

- Tasks must follow the state flow:
  1. `GET /tasks/new`
  2. If found, `POST /tasks/{id}/accept_task`
  3. Download and configure resources
  4. Start hashcat and begin periodic `submit_status`
  5. As hashes are cracked, `submit_crack`
  6. On success or keyspace exhaustion, call `/exhausted`
  7. If unrecoverable failure, call `/submit_error`
  8. On shutdown, call `/tasks/{id}/abandon`
- Agent must skip tasks if it lacks benchmark support for the hash type (use local cache of benchmark map).

## 8. Benchmarks

- Benchmark results must include `hash_type`, `runtime`, `hash_speed`, `device`
- Must support both native and packaged hashcat modes
- Results are sent to `/submit_benchmark` as part of initial setup or user-triggered rebenchmark
- Benchmark cache persists to `{data_path}/benchmark_cache.json`; submitted results are preserved, not cleared
- The `benchmarks_needed` flag from `/configuration` gates whether benchmarks run

## 9. Logging and Telemetry

- Use structured logs (`charmbracelet/log`) with timestamp, component, level, and message
- Never log secrets or sensitive data
- When dropping data during context cancellation, always log at Warn level

## 10. Future-Proofing

- Avoid hard-coding hashcat binary paths or formats
- Preserve compatibility with external configuration of wordlists, rules, masks
- Cracker management is now server-side only — the agent does not auto-update hashcat binaries
